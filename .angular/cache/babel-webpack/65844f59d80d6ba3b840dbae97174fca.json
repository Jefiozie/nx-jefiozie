{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport { InjectionToken, Injectable, Inject, ɵɵdefineInjectable, ɵɵinject, NgZone, isDevMode, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, NgModule } from '@angular/core';\nimport { NavigationStart, NavigationEnd, Router } from '@angular/router';\nimport { BehaviorSubject, NEVER, of, ReplaySubject, merge } from 'rxjs';\nimport { filter, switchMap, tap, first, map, shareReplay, pluck, take, takeWhile, catchError } from 'rxjs/operators';\nimport { DOCUMENT, Location } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/config/scully-config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/router';\nimport * as ɵngcc2 from '@angular/common';\nconst _c0 = [\"*\"];\n\nfunction ScullyLibConfig() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  ScullyLibConfig.prototype.useTransferState;\n  /** @type {?|undefined} */\n\n  ScullyLibConfig.prototype.alwaysMonitor;\n  /** @type {?|undefined} */\n\n  ScullyLibConfig.prototype.manualIdle;\n  /** @type {?|undefined} */\n\n  ScullyLibConfig.prototype.baseURIForScullyContent;\n}\n/** @type {?} */\n\n\nconst ScullyDefaultSettings = {\n  useTransferState: true,\n  alwaysMonitor: false,\n  manualIdle: false,\n  baseURIForScullyContent: 'http://localhost:1668'\n};\n/** @type {?} */\n\nconst SCULLY_LIB_CONFIG = new InjectionToken('scullyLibConfig', {\n  factory:\n  /**\n  * @return {?}\n  */\n  () => ScullyDefaultSettings\n});\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/utils/basePathOnly.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Take a string, preferably resembling an URL, take out the search params, the anchors, and the ending slash\n * \\@param str\n * @type {?}\n */\n\nconst basePathOnly =\n/**\n* @param {?} str\n* @return {?}\n*/\nstr => {\n  if (str.includes('#')) {\n    str = str.split('#')[0];\n  }\n\n  if (str.includes('?')) {\n    str = str.split('?')[0];\n  }\n  /** @type {?} */\n\n\n  const cleanedUpVersion = str.endsWith('/') ? str.slice(0, -1) : str;\n  return cleanedUpVersion;\n};\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/utils/fetchHttp.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T\n * @param {?} url\n * @param {?=} responseType\n * @return {?}\n */\n\n\nfunction fetchHttp(url, responseType = 'json') {\n  return new Promise(\n  /**\n  * @param {?} resolve\n  * @param {?} reject\n  * @return {?}\n  */\n  (resolve, reject) => {\n    /** @type {?} */\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = responseType;\n    xhr.addEventListener('load',\n    /**\n    * @param {?} ev\n    * @return {?}\n    */\n    ev => {\n      if (xhr.status !== 200) {\n        return reject(xhr);\n      }\n\n      resolve(xhr.response);\n    });\n    xhr.addEventListener('error',\n    /**\n    * @param {...?} err\n    * @return {?}\n    */\n    (...err) => reject(err));\n    xhr.open('get', url, true);\n    xhr.send();\n  });\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/utils/isScully.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable: no-string-literal\n\n/** @type {?} */\n\n\nconst isScullyRunning =\n/**\n* @return {?}\n*/\n() => window && window['ScullyIO'] === 'running';\n/** @type {?} */\n\n\nconst isScullyGenerated =\n/**\n* @return {?}\n*/\n() => window && window['ScullyIO'] === 'generated';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/utils/merge-paths.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} base\n * @param {?} path\n * @return {?}\n */\n\n\nfunction mergePaths(base, path) {\n  if (base.endsWith('/') && path.startsWith('/')) {\n    return `${base}${path.substr(1)}`;\n  }\n\n  if (!base.endsWith('/') && !path.startsWith('/')) {\n    return `${base}/${path}`;\n  }\n\n  return `${base}${path}`;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/transfer-state/transfer-state.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst SCULLY_SCRIPT_ID = `ScullyIO-transfer-state`;\n/** @type {?} */\n\nconst SCULLY_STATE_START = `/** ___SCULLY_STATE_START___ */`;\n/** @type {?} */\n\nconst SCULLY_STATE_END = `/** ___SCULLY_STATE_END___ */`;\n/** @type {?} */\n\nconst initialStateDone = '__done__with__Initial__navigation__';\n/**\n * @record\n */\n\nfunction State() {} // Adding this dynamic comment to suppress ngc error around Document as a DI token.\n// https://github.com/angular/angular/issues/20351#issuecomment-344009887\n\n/**\n * \\@dynamic\n */\n\n\nlet TransferStateService = /*#__PURE__*/(() => {\n  class TransferStateService {\n    /**\n     * @param {?} document\n     * @param {?} router\n     */\n    constructor(document, router) {\n      this.document = document;\n      this.router = router;\n      /**\n       * parse from index, or load from data.json, according to scullConfig setting\n       */\n\n      this.inlineOnly = false;\n      /**\n       * set the currentBase to something that it can never be\n       */\n\n      this.currentBaseUrl = '//';\n      /**\n       * subject to fire off incoming states\n       */\n\n      this.stateBS = new BehaviorSubject({});\n      this.state$ = this.stateBS.pipe(filter(\n      /**\n      * @param {?} state\n      * @return {?}\n      */\n      state => state !== undefined)); // emit the next url when routing is complete\n\n      this.nextUrl = this.router.events.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => e instanceof NavigationStart), switchMap(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        if (basePathOnly(this.initialUrl) === basePathOnly(e.url)) {\n          /** don't kick off on initial load to prevent flicker */\n          this.initialUrl = initialStateDone;\n          return NEVER;\n        }\n\n        return of(e);\n      }),\n      /** reset the state, so new components will never get stale data */\n      tap(\n      /**\n      * @return {?}\n      */\n      () => this.stateBS.next(undefined)),\n      /** prevent emitting before navigation to _this_ URL is done. */\n      switchMap(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => this.router.events.pipe(filter(\n      /**\n      * @param {?} ev\n      * @return {?}\n      */\n      ev => ev instanceof NavigationEnd && ev.url === e.url), first())), map(\n      /**\n      * @param {?} ev\n      * @return {?}\n      */\n      ev => basePathOnly(ev.urlAfterRedirects || ev.url)), shareReplay(1));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    startMonitoring() {\n      if (window && window['ScullyIO-injected'] && window['ScullyIO-injected'].inlineStateOnly) {\n        this.inlineOnly = true;\n      }\n\n      this.setupEnvForTransferState();\n      this.setupStartNavMonitoring();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    setupEnvForTransferState() {\n      if (isScullyRunning()) {\n        this.injectScript(); // In Scully puppeteer\n\n        /** @type {?} */\n\n        const exposed = window['ScullyIO-exposed'] || {};\n\n        if (exposed.transferState) {\n          this.stateBS.next(exposed.transferState);\n          this.saveState(exposed.transferState);\n        }\n      } else if (isScullyGenerated()) {\n        // On the client AFTER scully rendered it\n        this.initialUrl = window.location.pathname || '__no_NO_no__';\n        this.initialUrl = this.initialUrl !== '/' && this.initialUrl.endsWith('/') ? this.initialUrl.slice(0, -1) : this.initialUrl;\n        /** set the initial state */\n\n        this.stateBS.next(window && window[SCULLY_SCRIPT_ID] || {});\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    injectScript() {\n      this.script = this.document.createElement('script');\n      this.script.setAttribute('id', SCULLY_SCRIPT_ID);\n      /** @type {?} */\n\n      let last = document.body.lastChild;\n\n      while (last.previousSibling.nodeName === 'SCRIPT') {\n        last =\n        /** @type {?} */\n        last.previousSibling;\n      }\n\n      document.body.insertBefore(this.script, last);\n    }\n    /**\n     * Getstate will return an observable that containes the data.\n     * It does so right after the navigation for the page has finished.\n     * please note, this works SYNC on initial route, preventing a flash of content.\n     * @template T\n     * @param {?} name The name of the state to\n     * @return {?}\n     */\n\n\n    getState(name) {\n      /** start of the fetch for the current active route. */\n      this.fetchTransferState();\n      return this.state$.pipe(pluck(name) // tap((data) => console.log('tss', data))\n      );\n    }\n    /**\n     * Read the current state, and see if it has an value for the name.\n     * (note the value it containes still can be undefined!)\n     * @param {?} name\n     * @return {?}\n     */\n\n\n    stateHasKey(name) {\n      return this.stateBS.value && this.stateBS.value.hasOwnProperty(name);\n    }\n    /**\n     * Read the current state, and see if it has an value for the name.\n     * ys also if there is actually an value in the state.\n     * @param {?} name\n     * @return {?}\n     */\n\n\n    stateKeyHasValue(name) {\n      return this.stateBS.value && this.stateBS.value.hasOwnProperty(name) && this.stateBS.value[name] != null;\n    }\n    /**\n     * SetState will update the script in the generated page with data added.\n     * @template T\n     * @param {?} name\n     * @param {?} val\n     * @return {?}\n     */\n\n\n    setState(name, val) {\n      /** @type {?} */\n      const newState = Object.assign(Object.assign({}, this.stateBS.value), {\n        [name]: val\n      });\n      this.stateBS.next(newState);\n      this.saveState(newState);\n    }\n    /**\n     * @private\n     * @param {?} newState\n     * @return {?}\n     */\n\n\n    saveState(newState) {\n      if (isScullyRunning()) {\n        this.script.textContent = `{window['${SCULLY_SCRIPT_ID}']=_u(\\`${SCULLY_STATE_START}${escapeHtml(JSON.stringify(newState))}${SCULLY_STATE_END}\\`);function _u(t){t=t.split('${SCULLY_STATE_START}')[1].split('${SCULLY_STATE_END}')[0];const u={'_~b~': \"${'`'}\",'_~q~': \"'\",'_~o~': '$','_~s~': '/','_~l~': '<','_~g~': '>'};return JSON.parse(t.replace(/_~d~/g,'\\\\\\\\\"').replace(/_~[^]~/g, (s) => u[s]).replace(/\\\\n/g,'\\\\\\\\n').replace(/\\\\t/g,'\\\\\\\\t').replace(/\\\\r/g,'\\\\\\\\r'));}}`;\n      }\n    }\n    /**\n     * starts monitoring the router, and keep the url from the last completed navigation handy.\n     * @private\n     * @return {?}\n     */\n\n\n    setupStartNavMonitoring() {\n      if (!isScullyGenerated()) {\n        return;\n      }\n      /** start monitoring the routes */\n\n\n      this.nextUrl.subscribe();\n    }\n    /**\n     * Wraps an observable into scully's transfer state. If data for the provided `name` is\n     * available in the state, it gets returned. Otherwise, the `originalState` observable will\n     * be returned.\n     *\n     * On subsequent calls, the data in the state will always be returned. The `originalState` will\n     * be returned only once.\n     *\n     * This is a convenience method which does not require you to use `getState`/`setState` manually.\n     *\n     * @template T\n     * @param {?} name state key\n     * @param {?} originalState an observable which yields the desired data\n     * @return {?}\n     */\n\n\n    useScullyTransferState(name, originalState) {\n      if (isScullyGenerated()) {\n        return this.getState(name);\n      }\n\n      return originalState.pipe(tap(\n      /**\n      * @param {?} state\n      * @return {?}\n      */\n      state => this.setState(name, state)));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    fetchTransferState() {\n      return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * helper to read the part before the first slash (ignores leading slash)\n         * @type {?}\n         */\n        const base =\n        /**\n        * @param {?} url\n        * @return {?}\n        */\n        url => url.split('/').filter(\n        /**\n        * @param {?} part\n        * @return {?}\n        */\n        part => part.trim() !== '')[0];\n        /** put this in the next event cycle so the correct route can be read */\n\n\n        yield new Promise(\n        /**\n        * @param {?} r\n        * @return {?}\n        */\n        r => setTimeout(r, 0));\n        /**\n         * get the current url\n         * @type {?}\n         */\n\n        const currentUrl = yield this.nextUrl.pipe(take(1)).toPromise();\n        /** @type {?} */\n\n        const baseUrl = base(currentUrl);\n\n        if (this.currentBaseUrl === baseUrl) {\n          /** already monitoring, don't tho a thing */\n          return;\n        }\n        /** keep the baseUrl for later reference */\n\n\n        this.currentBaseUrl = baseUrl;\n        this.nextUrl.pipe(\n        /** keep updating till we move to another route */\n        takeWhile(\n        /**\n        * @param {?} url\n        * @return {?}\n        */\n        url => base(url) === this.currentBaseUrl), // Get the next route's data from the the index or data file\n        switchMap(\n        /**\n        * @param {?} url\n        * @return {?}\n        */\n        url => this.inlineOnly ? this.readFromIndex(url) : this.readFromJson(url)), catchError(\n        /**\n        * @param {?} e\n        * @return {?}\n        */\n        e => {\n          // TODO: come up with better error text.\n\n          /** the developer needs to know, but its not fatal, so just return an empty state */\n          console.warn('Error while loading of parsing Scully state:', e);\n          return of({});\n        }), tap(\n        /**\n        * @param {?} newState\n        * @return {?}\n        */\n        newState => {\n          /** and activate the state in the components. on any error it will be empty */\n          this.stateBS.next(newState);\n        })).subscribe({\n          /**\n           * when completes (different URL)\n           */\n          complete:\n          /**\n          * @return {?}\n          */\n          () => {\n            /** reset the currentBaseUrl */\n            this.currentBaseUrl = '//';\n          }\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {?} url\n     * @return {?}\n     */\n\n\n    readFromJson(url) {\n      return fetchHttp(dropPreSlash(mergePaths(url, '/data.json')));\n    }\n    /**\n     * @private\n     * @param {?} url\n     * @return {?}\n     */\n\n\n    readFromIndex(url) {\n      return fetchHttp(dropPreSlash(mergePaths(url, '/index.html')), 'text').then(\n      /**\n      * @param {?} html\n      * @return {?}\n      */\n      html => {\n        /** @type {?} */\n        const newStateStr = html.split(SCULLY_STATE_START)[1].split(SCULLY_STATE_END)[0];\n        return JSON.parse(unescapeHtml(newStateStr));\n      });\n    }\n\n  }\n\n  TransferStateService.ɵfac = function TransferStateService_Factory(t) {\n    return new (t || TransferStateService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc1.Router));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  TransferStateService.ɵprov = ɵɵdefineInjectable({\n    factory: function TransferStateService_Factory() {\n      return new TransferStateService(ɵɵinject(DOCUMENT), ɵɵinject(Router));\n    },\n    token: TransferStateService,\n    providedIn: \"root\"\n  });\n  return TransferStateService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  TransferStateService.prototype.script;\n  /**\n   * parse from index, or load from data.json, according to scullConfig setting\n   * @type {?}\n   * @private\n   */\n\n  TransferStateService.prototype.inlineOnly;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TransferStateService.prototype.initialUrl;\n  /**\n   * set the currentBase to something that it can never be\n   * @type {?}\n   * @private\n   */\n\n  TransferStateService.prototype.currentBaseUrl;\n  /**\n   * subject to fire off incoming states\n   * @type {?}\n   * @private\n   */\n\n  TransferStateService.prototype.stateBS;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TransferStateService.prototype.state$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TransferStateService.prototype.nextUrl;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TransferStateService.prototype.document;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TransferStateService.prototype.router;\n}\n/**\n * @param {?} string\n * @return {?}\n */\n\n\nfunction dropPreSlash(string) {\n  return string.startsWith('/') ? string.slice(1) : string;\n}\n/**\n * we need to escape our HTML to prevent XXS,\n * It needs to be custom, because the content can already contain html-escaped sequences\n *\n * @param {?} text\n * @return {?}\n */\n\n\nfunction escapeHtml(text) {\n  /** @type {?} */\n  const escapedText = {\n    \"'\": '_~q~',\n    $: '_~o~',\n    '`': '_~b~',\n    '/': '_~s~',\n    '<': '_~l~',\n    '>': '_~g~'\n  };\n  return text\n  /** escape the json */\n  .replace(/[\\$`'<>\\/]/g,\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  s => escapedText[s])\n  /** replace escaped double-quotes with single */\n  .replace(/\\\\\\\"/g, `_~d~`);\n}\n/**\n * Unescape our custom escaped texts\n * @param {?} text\n * @return {?}\n */\n\n\nfunction unescapeHtml(text) {\n  /** @type {?} */\n  const unescapedText = {\n    '_~q~': \"'\",\n    '_~b~': '`',\n    '_~o~': '$',\n    '_~s~': '/',\n    '_~l~': '<',\n    '_~g~': '>'\n  };\n  return text\n  /** put back escaped double quotes to make valid json again */\n  .replace(/_~d~/g, `\\\\\"`)\n  /** replace the custom escapes */\n  .replace(/_~[^]~/g,\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  s => unescapedText[s])\n  /** restore newlines+cr */\n  .replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/idleMonitor/idle-monitor.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction LocalState() {}\n\nif (false) {\n  /** @type {?} */\n  LocalState.prototype.idle;\n  /** @type {?} */\n\n  LocalState.prototype.timeOut;\n} // if (window) {\n//   window.addEventListener('AngularReady', ev => {\n//     console.log('appReady fired', ev);\n//   });\n// }\n\n\nlet IdleMonitorService = /*#__PURE__*/(() => {\n  class IdleMonitorService {\n    /**\n     * @param {?} zone\n     * @param {?} router\n     * @param {?} conf\n     * @param {?} tss\n     */\n    constructor(zone, router, conf, tss) {\n      this.zone = zone;\n      this.router = router;\n      /**\n       * store the 'landing' url so we can skip it in idle-check.\n       */\n\n      this.initialUrl = dropEndingSlash(window && window.location && window.location.pathname) || '';\n      this.imState = new BehaviorSubject({\n        idle: false,\n        timeOut: 5 * 1000\n      });\n      this.idle$ = this.imState.pipe(pluck('idle'));\n      this.initApp = new Event('AngularInitialized', {\n        bubbles: true,\n        cancelable: false\n      });\n      this.appReady = new Event('AngularReady', {\n        bubbles: true,\n        cancelable: false\n      });\n      this.appTimeout = new Event('AngularTimeout', {\n        bubbles: true,\n        cancelable: false\n      });\n      /** provide the default for missing conf paramter */\n\n      this.scullyLibConfig = Object.assign({}, ScullyDefaultSettings, conf);\n      /** @type {?} */\n\n      const exposed = window['ScullyIO-exposed'] || {};\n      /** @type {?} */\n\n      const manualIdle = !!exposed.manualIdle;\n\n      if (!this.scullyLibConfig.manualIdle && window && (this.scullyLibConfig.alwaysMonitor || isScullyRunning())) {\n        window.dispatchEvent(this.initApp);\n        this.router.events.pipe(filter(\n        /**\n        * @param {?} ev\n        * @return {?}\n        */\n        ev => ev instanceof NavigationEnd && ev.urlAfterRedirects !== undefined),\n        /** don't check the page that has this setting. event is only importand on page load */\n        filter(\n        /**\n        * @param {?} ev\n        * @return {?}\n        */\n        ev => manualIdle ? ev.urlAfterRedirects !== this.initialUrl : true), tap(\n        /**\n        * @return {?}\n        */\n        () => this.zoneIdleCheck())).subscribe();\n      }\n\n      if (this.scullyLibConfig.manualIdle) {\n        /** we still need the init event. */\n        window.dispatchEvent(this.initApp);\n      }\n\n      if (this.scullyLibConfig.useTransferState) {\n        /** don't start monitoring if people don't use the transferState */\n        tss.startMonitoring();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    fireManualMyAppReadyEvent() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return window.dispatchEvent(this.appReady);\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n\n    init() {\n      return __awaiter(this, void 0, void 0, function* () {\n        return this.idle$.pipe(take(1)).toPromise();\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    zoneIdleCheck() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (Zone === undefined) {\n          return this.simpleTimeout();\n        }\n        /** @type {?} */\n\n\n        const taskTrackingZone = Zone.current.get('TaskTrackingZone');\n\n        if (taskTrackingZone === undefined) {\n          return this.simpleTimeout();\n        }\n\n        if (this.imState.value.idle) {\n          yield this.setState('idle', false);\n        }\n        /** run the actual check for 'idle' outsides zone, otherwise it will never come to an end. */\n\n\n        this.zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        () => {\n          /** @type {?} */\n          let tCancel;\n          /** @type {?} */\n\n          let count = 0;\n          /** @type {?} */\n\n          const startTime = Date.now();\n          /** @type {?} */\n\n          const monitor =\n          /**\n          * @return {?}\n          */\n          () => {\n            clearTimeout(tCancel); // console.table(taskTrackingZone.macroTasks);\n\n            if (Date.now() - startTime > 30 * 1000) {\n              /** bail out after 30 seconds. */\n              window.dispatchEvent(this.appTimeout);\n              return;\n            }\n\n            if (taskTrackingZone.macroTasks.length > 0 && taskTrackingZone.macroTasks.find(\n            /**\n            * @param {?} z\n            * @return {?}\n            */\n            z => z.source.includes('XMLHttpRequest')) !== undefined || count < 1 // make sure it runs at least once!\n            ) {\n              tCancel = setTimeout(\n              /**\n              * @return {?}\n              */\n              () => {\n                count += 1;\n                monitor();\n              }, 50);\n              return;\n            }\n\n            this.zone.run(\n            /**\n            * @return {?}\n            */\n            () => {\n              /** run this inside the zone, and give the app 250Ms to wrap up, before scraping starts */\n              setTimeout(\n              /**\n              * @return {?}\n              */\n              () => {\n                window.dispatchEvent(this.appReady);\n                this.setState('idle', true);\n              }, 250);\n            });\n          };\n\n          monitor();\n        });\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    simpleTimeout() {\n      return __awaiter(this, void 0, void 0, function* () {\n        /** zone not available, use a timeout instead. */\n        console.warn('Scully is using timeouts, add the needed polyfills instead!');\n        yield new Promise(\n        /**\n        * @param {?} r\n        * @return {?}\n        */\n        r => setTimeout(r, this.imState.value.timeOut));\n        window.dispatchEvent(this.appReady);\n      });\n    }\n    /**\n     * @param {?} milliseconds\n     * @return {?}\n     */\n\n\n    setPupeteerTimeoutValue(milliseconds) {\n      this.imState.next(Object.assign(Object.assign({}, this.imState.value), {\n        timeOut: milliseconds\n      }));\n    }\n    /**\n     * @private\n     * @param {?} key\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    setState(key, value) {\n      this.imState.next(Object.assign(Object.assign({}, this.imState.value), {\n        [key]: value\n      }));\n    }\n\n  }\n\n  IdleMonitorService.ɵfac = function IdleMonitorService_Factory(t) {\n    return new (t || IdleMonitorService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(SCULLY_LIB_CONFIG), ɵngcc0.ɵɵinject(TransferStateService));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  IdleMonitorService.ɵprov = ɵɵdefineInjectable({\n    factory: function IdleMonitorService_Factory() {\n      return new IdleMonitorService(ɵɵinject(NgZone), ɵɵinject(Router), ɵɵinject(SCULLY_LIB_CONFIG), ɵɵinject(TransferStateService));\n    },\n    token: IdleMonitorService,\n    providedIn: \"root\"\n  });\n  return IdleMonitorService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  IdleMonitorService.prototype.scullyLibConfig;\n  /**\n   * store the 'landing' url so we can skip it in idle-check.\n   * @type {?}\n   * @private\n   */\n\n  IdleMonitorService.prototype.initialUrl;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IdleMonitorService.prototype.imState;\n  /** @type {?} */\n\n  IdleMonitorService.prototype.idle$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IdleMonitorService.prototype.initApp;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IdleMonitorService.prototype.appReady;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IdleMonitorService.prototype.appTimeout;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IdleMonitorService.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  IdleMonitorService.prototype.router;\n}\n/**\n * @param {?} str\n * @return {?}\n */\n\n\nfunction dropEndingSlash(str) {\n  return str.endsWith('/') ? str.slice(0, -1) : str;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/route-service/scully-routes.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction ScullyRoute() {}\n\nif (false) {\n  /** @type {?} */\n  ScullyRoute.prototype.route;\n  /** @type {?|undefined} */\n\n  ScullyRoute.prototype.title;\n  /** @type {?|undefined} */\n\n  ScullyRoute.prototype.slugs;\n  /** @type {?|undefined} */\n\n  ScullyRoute.prototype.published;\n  /** @type {?|undefined} */\n\n  ScullyRoute.prototype.slug;\n  /** @type {?|undefined} */\n\n  ScullyRoute.prototype.sourceFile;\n  /** @type {?|undefined} */\n\n  ScullyRoute.prototype.lang;\n  /* Skipping unhandled member: [prop: string]: any;*/\n}\n\nlet ScullyRoutesService = /*#__PURE__*/(() => {\n  class ScullyRoutesService {\n    /**\n     * @param {?} router\n     */\n    constructor(router) {\n      this.router = router;\n      this.refresh = new ReplaySubject(1);\n      /**\n       * An observable with all routes, published and unpublished alike\n       */\n\n      this.allRoutes$ = this.refresh.pipe(switchMap(\n      /**\n      * @return {?}\n      */\n      () => fetchHttp('assets/scully-routes.json')), catchError(\n      /**\n      * @return {?}\n      */\n      () => {\n        console.warn('Scully routes file not found, are you running the Scully generated version of your site?');\n        return of(\n        /** @type {?} */\n        []);\n      }),\n      /** filter out all non-array results */\n      filter(\n      /**\n      * @param {?} routes\n      * @return {?}\n      */\n      routes => Array.isArray(routes)), map(this.cleanDups), shareReplay({\n        refCount: false,\n        bufferSize: 1\n      }));\n      /**\n       * An observable with available routes (all published routes)\n       */\n\n      this.available$ = this.allRoutes$.pipe(map(\n      /**\n      * @param {?} list\n      * @return {?}\n      */\n      list => list.filter(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => r.hasOwnProperty('published') ? r.published !== false : true)), shareReplay({\n        refCount: false,\n        bufferSize: 1\n      }));\n      /**\n       * an observable with all unpublished routes\n       */\n\n      this.unPublished$ = this.allRoutes$.pipe(map(\n      /**\n      * @param {?} list\n      * @return {?}\n      */\n      list => list.filter(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => r.hasOwnProperty('published') ? r.published === false : false)), shareReplay({\n        refCount: false,\n        bufferSize: 1\n      }));\n      /**\n       * An observable with the top-level off all published routes.\n       * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)\n       */\n\n      this.topLevel$ = this.available$.pipe(map(\n      /**\n      * @param {?} routes\n      * @return {?}\n      */\n      routes => routes.filter(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => !r.route.slice(1).includes('/'))), shareReplay({\n        refCount: false,\n        bufferSize: 1\n      }));\n      /** kick off first cycle */\n\n      this.reload();\n    }\n    /**\n     * returns an observable that returns the route information for the\n     * route currently selected. subscribes to route-events to update when needed\n     * @return {?}\n     */\n\n\n    getCurrent() {\n      if (!location) {\n        /** probably not in a browser, no current location available */\n        return of();\n      }\n      /** fire off at start, and when navigation is done. */\n\n\n      return merge(of(new NavigationEnd(0, '', '')), this.router.events).pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => e instanceof NavigationEnd), switchMap(\n      /**\n      * @return {?}\n      */\n      () => this.available$), map(\n      /**\n      * @param {?} list\n      * @return {?}\n      */\n      list => {\n        /** @type {?} */\n        const curLocation = basePathOnly(encodeURI(location.pathname).trim());\n        return list.find(\n        /**\n        * @param {?} r\n        * @return {?}\n        */\n        r => curLocation === basePathOnly(r.route.trim()) || r.slugs && Array.isArray(r.slugs) && r.slugs.find(\n        /**\n        * @param {?} slug\n        * @return {?}\n        */\n        slug => curLocation.endsWith(basePathOnly(slug.trim()))));\n      }));\n    }\n    /**\n     * internal, as routes can have multiple slugs, and so occur multiple times\n     * this util function collapses all slugs back into 1 route.\n     * @private\n     * @param {?} routes\n     * @return {?}\n     */\n\n\n    cleanDups(routes) {\n      /** @type {?} */\n      const m = new Map();\n      /** check for duplicates by comparing all, include route in comparison if its the only thing, or the only thing with only the tile  */\n\n      routes.forEach(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => m.set(JSON.stringify(Object.assign(Object.assign({}, r), {\n        route: hasOtherprops(r) ? '' : r.route\n      })), r));\n      return [...m.values()];\n    }\n    /**\n     * an utility that will force a reload of the `scully-routes.json` file\n     * @return {?}\n     */\n\n\n    reload() {\n      this.refresh.next();\n    }\n\n  }\n\n  ScullyRoutesService.ɵfac = function ScullyRoutesService_Factory(t) {\n    return new (t || ScullyRoutesService)(ɵngcc0.ɵɵinject(ɵngcc1.Router));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  ScullyRoutesService.ɵprov = ɵɵdefineInjectable({\n    factory: function ScullyRoutesService_Factory() {\n      return new ScullyRoutesService(ɵɵinject(Router));\n    },\n    token: ScullyRoutesService,\n    providedIn: \"root\"\n  });\n  return ScullyRoutesService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ScullyRoutesService.prototype.refresh;\n  /**\n   * An observable with all routes, published and unpublished alike\n   * @type {?}\n   */\n\n  ScullyRoutesService.prototype.allRoutes$;\n  /**\n   * An observable with available routes (all published routes)\n   * @type {?}\n   */\n\n  ScullyRoutesService.prototype.available$;\n  /**\n   * an observable with all unpublished routes\n   * @type {?}\n   */\n\n  ScullyRoutesService.prototype.unPublished$;\n  /**\n   * An observable with the top-level off all published routes.\n   * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)\n   * @type {?}\n   */\n\n  ScullyRoutesService.prototype.topLevel$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ScullyRoutesService.prototype.router;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\n\n\nfunction hasOtherprops(obj) {\n  /** @type {?} */\n  const keys = Object.keys(obj);\n\n  if (keys.length === 1 && keys.includes('route')) {\n    return false;\n  }\n\n  if (keys.length === 2 && keys.includes('route') && keys.includes('title')) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/utils/findComments.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns an array of nodes coninting all the html comments in the element.\n * When a searchText is given this is narrowed down to only comments that contian this text\n * @param {?} rootElem Element to search nto\n * @param {?=} searchText optional string that needs to be in a HTML comment\n * @return {?}\n */\n\n\nfunction findComments(rootElem, searchText) {\n  /** @type {?} */\n  const comments = []; // Fourth argument, which is actually obsolete according to the DOM4 standard, seems required in IE 11\n\n  /** @type {?} */\n\n  const iterator = document.createNodeIterator(rootElem, NodeFilter.SHOW_COMMENT, {\n    acceptNode:\n    /**\n    * @param {?} node\n    * @return {?}\n    */\n    node => {\n      // Logic to determine whether to accept, reject or skip node\n      // In this case, only accept nodes that have content\n      // that is containing our searchText, by rejecting any other nodes.\n      if (searchText && node.nodeValue && !node.nodeValue.includes(searchText)) {\n        return NodeFilter.FILTER_REJECT;\n      }\n\n      return NodeFilter.FILTER_ACCEPT;\n    }\n  } // , false // IE-11 support requires this parameter.\n  );\n  /** @type {?} */\n\n  let curNode; // tslint:disable-next-line: no-conditional-assignment\n\n  while (curNode = iterator.nextNode()) {\n    comments.push(curNode);\n  }\n\n  return comments;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/scully-content/scully-content.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction ScullyContent() {}\n\nif (false) {\n  /** @type {?} */\n  ScullyContent.prototype.html;\n  /** @type {?} */\n\n  ScullyContent.prototype.cssId;\n}\n/**\n * this is needed, because otherwise the CLI borks while building\n * @type {?}\n */\n\n\nconst scullyBegin = '<!--scullyContent-begin-->';\n/** @type {?} */\n\nconst scullyEnd = '<!--scullyContent-end-->';\n/**\n * use the module's closure to keep a system-wide check for the last handled URL.\n * @type {?}\n */\n\nlet lastHandled;\nlet ScullyContentComponent = /*#__PURE__*/(() => {\n  class ScullyContentComponent {\n    /**\n     * @param {?} elmRef\n     * @param {?} srs\n     * @param {?} router\n     * @param {?} location\n     * @param {?} conf\n     */\n    constructor(elmRef, srs, router, location, conf) {\n      this.elmRef = elmRef;\n      this.srs = srs;\n      this.router = router;\n      this.location = location;\n      this.conf = conf;\n      this.baseUrl = this.conf.useTransferState || ScullyDefaultSettings.useTransferState;\n      this.elm =\n      /** @type {?} */\n      this.elmRef.nativeElement;\n      /**\n       * pull in all  available routes into an eager promise\n       */\n\n      this.routes = this.srs.allRoutes$.pipe(take(1)).toPromise();\n      /**\n       * monitor the router, so we can update while navigating in the same 'page' see #311\n       */\n\n      this.routeUpdates$ = this.router.events.pipe(filter(\n      /**\n      * @param {?} ev\n      * @return {?}\n      */\n      ev => ev instanceof NavigationEnd),\n      /** don't replace if we are already there */\n      filter(\n      /**\n      * @param {?} ev\n      * @return {?}\n      */\n      ev => lastHandled && !lastHandled.endsWith(ev.urlAfterRedirects)), tap(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => this.replaceContent()));\n      this.routeSub = this.routeUpdates$.subscribe();\n      /** do this from constructor, so it runs ASAP */\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      if (this.elm) {\n        /** this will only fire in a browser environment */\n        this.handlePage();\n      }\n    }\n    /**\n     * Loads the static content from scully into the view\n     * Will fetch the content from sibling links with xmlHTTPrequest\n     * @private\n     * @return {?}\n     */\n\n\n    handlePage() {\n      return __awaiter(this, void 0, void 0, function* () {\n        /** @type {?} */\n        const curPage = basePathOnly(location.href);\n\n        if (lastHandled === curPage) {\n          /**\n           * Due to the fix we needed for #311\n           * it might happen that this routine is called\n           * twice for the same page.\n           * this code will make sure the second one is ignored.\n           */\n          return;\n        }\n\n        lastHandled = curPage;\n        /** @type {?} */\n\n        const template = document.createElement('template');\n        /** @type {?} */\n\n        const currentCssId = this.getCSSId(this.elm);\n\n        if (window.scullyContent) {\n          /**\n           * upgrade existing static content\n           * @type {?}\n           */\n          const htmlString = window.scullyContent.html;\n\n          if (currentCssId !== window.scullyContent.cssId) {\n            /** replace the angular cssId */\n            template.innerHTML = htmlString.split(window.scullyContent.cssId).join(currentCssId);\n          } else {\n            template.innerHTML = htmlString;\n          }\n        } else {\n          /**\n           *   NOTE\n           * when updateting the texts for the errors, make sure you leave the\n           *  `id=\"___scully-parsing-error___\"`\n           * in there. That way users can detect rendering errors in their CI\n           * on a reliable way.\n           */\n          yield fetchHttp(curPage + '/index.html', 'text').catch(\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          e => {\n            if (isDevMode()) {\n              /**\n               * in devmode (usually in `ng serve`) check the scully server for the content too\n               * @type {?}\n               */\n              const uri = new URL(location.href);\n              /** @type {?} */\n\n              const url = `${this.conf.baseURIForScullyContent}/${basePathOnly(uri.pathname)}/index.html`;\n              return fetchHttp(url, 'text');\n            } else {\n              return Promise.reject(e);\n            }\n          }).then(\n          /**\n          * @param {?} html\n          * @return {?}\n          */\n          html => {\n            try {\n              /** @type {?} */\n              const htmlString = html.split(scullyBegin)[1].split(scullyEnd)[0];\n\n              if (htmlString.includes('_ngcontent')) {\n                /**\n                 * update the angular cssId\n                 * @type {?}\n                 */\n                const atr = '_ngcontent' + htmlString.split('_ngcontent')[1].split('=')[0];\n                template.innerHTML = htmlString.split(atr).join(currentCssId);\n              } else {\n                template.innerHTML = htmlString;\n              }\n            } catch (e) {\n              template.innerHTML = `<h2 id=\"___scully-parsing-error___\">Sorry, could not parse static page content</h2>\n            <p>This might happen if you are not using the static generated pages.</p>`;\n            }\n          }).catch(\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          e => {\n            template.innerHTML = '<h2 id=\"___scully-parsing-error___\">Sorry, could not load static page content</h2>';\n            console.error('problem during loading static scully content', e);\n          });\n        }\n        /**\n         * insert the whole thing just before the `<scully-content>` element\n         * @type {?}\n         */\n\n\n        const parent = this.elm.parentElement || document.body;\n        /** @type {?} */\n\n        const begin = document.createComment('scullyContent-begin');\n        /** @type {?} */\n\n        const end = document.createComment('scullyContent-end');\n        parent.insertBefore(begin, this.elm);\n        parent.insertBefore(template.content, this.elm);\n        parent.insertBefore(end, this.elm);\n        /** upgrade all hrefs to simulated routelinks (in next microtask) */\n\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        () => document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this)), 10); // document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this));\n      });\n    }\n    /**\n     * upgrade a **href** attributes to links that respect the Angular router\n     * and don't do a full page reload. Only works on links that are found in the\n     * Scully route config file.\n     * @param {?} elm the element containing the **hrefs**\n     * @return {?}\n     */\n\n\n    upgradeToRoutelink(elm) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!['A', 'BUTTON'].includes(elm.tagName)) {\n          return;\n        }\n        /** @type {?} */\n\n\n        const hash = elm.dataset.hash;\n\n        if (hash) {\n          elm.setAttribute('href', '#' + hash);\n          elm.setAttribute('onclick', '');\n\n          elm.onclick =\n          /**\n          * @param {?} ev\n          * @return {?}\n          */\n          ev => {\n            ev.preventDefault();\n            /** @type {?} */\n\n            const destination = document.getElementById(hash);\n\n            if (destination) {\n              /** @type {?} */\n              const url = new URL(window.location.href);\n              url.hash = hash;\n              history.replaceState('', '', url.toString());\n              destination.scrollIntoView();\n            }\n          };\n\n          return;\n        }\n        /** @type {?} */\n\n\n        const routes = yield this.routes;\n        /** @type {?} */\n\n        const href = elm.getAttribute('href');\n        /** @type {?} */\n\n        const lnk = basePathOnly(href.toLowerCase());\n        /** @type {?} */\n\n        const route = routes.find(\n        /**\n        * @param {?} r\n        * @return {?}\n        */\n        r => basePathOnly(r.route.toLowerCase()) === lnk);\n        /** only upgrade routes known by scully. */\n\n        if (lnk && route && !lnk.startsWith('#')) {\n          elm.onclick =\n          /**\n          * @param {?} ev\n          * @return {?}\n          */\n          ev => __awaiter(this, void 0, void 0, function* () {\n            /** @type {?} */\n            const splitRoute = route.route.split(`/`);\n            /** @type {?} */\n\n            const curSplit = location.pathname.split('/'); // loose last \"part\" of route\n\n            curSplit.pop();\n            ev.preventDefault();\n            /** @type {?} */\n\n            const routed = yield this.router.navigate(splitRoute).catch(\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n            e => {\n              console.error('routing error', e);\n              return false;\n            });\n\n            if (!routed) {\n              return;\n            }\n            /** check for the same route with different \"data\", and NOT a 1 level higher (length), and is not a fragment of th same page */\n\n\n            if (curSplit.every(\n            /**\n            * @param {?} part\n            * @param {?} i\n            * @return {?}\n            */\n            (part, i) => splitRoute[i] === part) && splitRoute.length !== curSplit.length + 1) {\n              setTimeout(\n              /**\n              * @return {?}\n              */\n              () => this.replaceContent(), 10); // a small delay, so we are sure the angular parts in the page are settled enough\n            }\n          });\n        }\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    replaceContent() {\n      /**\n       * as Angular doesn't destroy the component if we stay on the same page,\n       * we have to manually delete old content. Also we need to kick of loading\n       * the new content. handlePage() takes care of that.\n       */\n\n      /** delete the content, as it is now out of date! */\n      window.scullyContent = undefined;\n      /** @type {?} */\n\n      const parent = this.elm.parentElement;\n      /** @type {?} */\n\n      let cur =\n      /** @type {?} */\n      findComments(parent, 'scullyContent-begin')[0];\n\n      while (cur && cur !== this.elm) {\n        /** @type {?} */\n        const next = cur.nextSibling;\n        parent.removeChild(cur);\n        cur = next;\n      }\n\n      this.handlePage();\n    }\n    /**\n     * @param {?} elm\n     * @return {?}\n     */\n\n\n    getCSSId(elm) {\n      return elm.getAttributeNames().find(\n      /**\n      * @param {?} a\n      * @return {?}\n      */\n      a => a.startsWith('_ngcontent')) || '';\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.routeSub.unsubscribe();\n      /** reset the lastused */\n\n      lastHandled = '//';\n    }\n\n  }\n\n  ScullyContentComponent.ɵfac = function ScullyContentComponent_Factory(t) {\n    return new (t || ScullyContentComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScullyRoutesService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Location), ɵngcc0.ɵɵdirectiveInject(SCULLY_LIB_CONFIG));\n  };\n\n  ScullyContentComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ScullyContentComponent,\n    selectors: [[\"scully-content\"]],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function ScullyContentComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"\\n      :host {\\n        display: none;\\n      }\\n      scully-content {\\n        display: none;\\n      }\\n    \"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  /** @nocollapse */\n\n  return ScullyContentComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  ScullyContentComponent.prototype.baseUrl;\n  /** @type {?} */\n\n  ScullyContentComponent.prototype.elm;\n  /**\n   * pull in all  available routes into an eager promise\n   * @type {?}\n   */\n\n  ScullyContentComponent.prototype.routes;\n  /**\n   * monitor the router, so we can update while navigating in the same 'page' see #311\n   * @type {?}\n   */\n\n  ScullyContentComponent.prototype.routeUpdates$;\n  /** @type {?} */\n\n  ScullyContentComponent.prototype.routeSub;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ScullyContentComponent.prototype.elmRef;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ScullyContentComponent.prototype.srs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ScullyContentComponent.prototype.router;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ScullyContentComponent.prototype.location;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ScullyContentComponent.prototype.conf;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/scully-content/scully-content.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ScullyContentModule = /*#__PURE__*/(() => {\n  class ScullyContentModule {}\n\n  ScullyContentModule.ɵfac = function ScullyContentModule_Factory(t) {\n    return new (t || ScullyContentModule)();\n  };\n\n  ScullyContentModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ScullyContentModule\n  });\n  ScullyContentModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return ScullyContentModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScullyContentModule, {\n    declarations: [ScullyContentComponent],\n    exports: [ScullyContentComponent]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/scully-lib.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ScullyLibModule = /*#__PURE__*/(() => {\n  class ScullyLibModule {\n    /**\n     * @param {?} idle\n     */\n    constructor(idle) {\n      this.idle = idle;\n    }\n    /**\n     * We use a little trick to get a working idle-service.\n     * First, we separate out the component in a separate module to prevent a circulair injection\n     * second we create a constuctor that activates the IdleMonitorService. as that is provided for 'root'\n     * there will be only 1 instance in our app.\n     * We don't need forRoot, as we are not configuring anything in here.\n     * @param {?=} config\n     * @return {?}\n     */\n\n\n    static forRoot(config = ScullyDefaultSettings) {\n      config = Object.assign({}, ScullyDefaultSettings, config);\n      return {\n        ngModule: ScullyLibModule,\n        providers: [{\n          provide: SCULLY_LIB_CONFIG,\n          useValue: config\n        }]\n      };\n    }\n\n  }\n\n  ScullyLibModule.ɵfac = function ScullyLibModule_Factory(t) {\n    return new (t || ScullyLibModule)(ɵngcc0.ɵɵinject(IdleMonitorService));\n  };\n\n  ScullyLibModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ScullyLibModule\n  });\n  ScullyLibModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[ScullyContentModule], ScullyContentModule]\n  });\n  /** @nocollapse */\n\n  return ScullyLibModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ScullyLibModule, {\n    imports: [ScullyContentModule],\n    exports: [ScullyContentModule]\n  });\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ScullyLibModule.prototype.idle;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: scullyio-ng-lib.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { IdleMonitorService, ScullyContentComponent, ScullyContentModule, ScullyLibModule, ScullyRoutesService, TransferStateService, dropEndingSlash, isScullyGenerated, isScullyRunning, SCULLY_LIB_CONFIG as ɵb }; //# sourceMappingURL=scullyio-ng-lib.js.map","map":null,"metadata":{},"sourceType":"module"}